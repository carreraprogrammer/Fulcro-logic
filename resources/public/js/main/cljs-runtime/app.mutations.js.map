{"version":3,"sources":["app/mutations.cljs"],"mappings":";AAGA,AAAA;;;AAAAA,8BAAA,AAAAC,+CAAA,AAAA;;AAAA,AAAAC,oFAAA,AAAA,oGAAA,WAAAC;AAAA,AAAA,IAAAC,aAAA,AAAA,sFAAA,AAAA,iFAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;gBAAA,AAAAE,4CAAAF,eAAA,vEAEWc;WAFX,AAAAZ,4CAAAF,eAAA,lEAEqBe;AAFrB,AAAA,kDAAA,yDAAA,+BAAAZ;AAAA,AAAA,IAAAC,aAAAD;IAAAC,iBAAA,AAAAH,4BAAAG;YAAA,AAAAF,4CAAAE,eAAA,nEAGmBY;AAHnB,AAAA,IAAAX,iDAAAC;IAAAC,iDAAA;AAAA,AAAA,CAAAD,iEAAAC;;AAAA,IAAA,AAIU,IAAMU,aAAS,qEAAA,mFAAA,2DAAA,wEAAA,mFAAA,2DAAA,vaAAI,6CAAA,7CAACC,uDAAYJ;IAG1BK,iBAAS,+CAAA,AAAAC,/CAACC,+DAAQL,OAAMC;IACxBK,iBAAS,AAACC,cAAI,+CAAA,WAAAC,1DAACC;AAAD,AAAS,OAACC,gDAAK,AAAA,6FAAAF,kBAAiBT;GAAMI;AAJ1D,AAKE,AAACQ,mDAAMX,MAAMY,mBAASX,WAAKK;UATvC,AAAA,CAAAhB,iEAAAD;;AAAA;GAAA,wEAAA,WAAAG;AAAA,AAAA,IAAAC,2CAAAH;IAAAI,2CAAA;AAAA,AAAA,CAAAJ,iEAAAI;;AAAA,IAAA,AAAA,IAAAC,qBAAA,AAAAC,uDAAA,AAAA,iFAAAJ,KAAA;AAAA,AAAA,oBAAAG;AAAA,AAAA,IAAAE,iBAAAF;AAAA,AAAA,QAAAE,+CAAAA,6CAAAL,OAAAK,yBAAAL;;AAAA;;UAAA,AAAA,CAAAF,iEAAAG","names":["app.mutations/delete-person","com.fulcrologic.fulcro.mutations/->Mutation","com.fulcrologic.fulcro.mutations/mutate","fulcro-mutation-env-symbol","map__48969","cljs.core/--destructure-map","cljs.core.get","p__48970","map__48971","*after-render*-orig-val__48972","com.fulcrologic.fulcro.raw.components/*after-render*","*after-render*-temp-val__48973","env","*after-render*-orig-val__48974","*after-render*-temp-val__48975","temp__5753__auto__","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","default-action","list-name","name","state","path","cljs.core._EQ_","old-list","cljs.core/deref","cljs.core.get_in","new-list","cljs.core/vec","p1__48968#","cljs.core.filter","cljs.core.not_EQ_","cljs.core.swap_BANG_","cljs.core/assoc-in"],"sourcesContent":["(ns app.mutations\r\n  (:require [com.fulcrologic.fulcro.mutations :as m :refer [defmutation]]))\r\n\r\n(defmutation delete-person\r\n  \"Mutation: Delete the person with `name` from the list with `list-name`\"\r\n  [{:keys [list-name name]}] ; (1)\r\n  (action [{:keys [state]}] ; (2)\r\n          (let [path     (if (= \"Friends\" list-name)\r\n                           [:friends :list/people]\r\n                           [:enemies :list/people])\r\n                old-list (get-in @state path)\r\n                new-list (vec (filter #(not= (:person/name %) name) old-list))]\r\n            (swap! state assoc-in path new-list))))"]}